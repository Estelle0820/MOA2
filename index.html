<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>MOA2 Experiment</title>
  <link rel="stylesheet" href="https://unpkg.com/jspsych@7.3.4/css/jspsych.css" />
  <style>
    body { font-family: system-ui, sans-serif; background:#fafafa; }
    .wrap  { max-width: 980px; margin: 32px auto; }
    .center { text-align:center; }
    video  { display:block; margin: 0 auto; border-radius: 10px; background:#000; }
    .grid  { display:grid; grid-template-columns: 1fr 1fr; gap:16px; align-items:start; }
    .cell  { display:flex; flex-direction:column; align-items:center; text-align:center; padding:8px; background:#fff; border-radius:12px; box-shadow:0 1px 3px rgba(0,0,0,.06); }

    /* Uniform stems and option images (same display box, no distortion) */
    .stem  { display:block; margin: 8px auto 16px; max-width: 900px; width:100%; height:260px; object-fit:contain; }
    .optimg{ width:100%; max-width:360px; height:220px; object-fit:contain; display:block; margin:8px auto; background:#fff; }
    .opttext{ margin:10px 8px; }

    /* Slider labels: 0–4 */
    .jspsych-slider-container .jspsych-slider-labels {
      display: flex !important;
      justify-content: space-between !important;
      gap: 0 !important;
      margin-top: 10px !important;
      font-size: 14px !important;
      line-height: 1.2 !important;
      color: #111 !important;
      white-space: nowrap !important;
    }
    .jspsych-slider-container .jspsych-slider-label {
      text-align: center !important;
      flex: 0 0 auto !important;
    }

    /* Hide the video seek bar + time displays (leave play/pause) */
    video::-webkit-media-controls-timeline,
    video::-webkit-media-controls-current-time-display,
    video::-webkit-media-controls-time-remaining-display { display: none !important; }
    video::-moz-media-controls-seekbar { display: none !important; }
  </style>
</head>
<body></body>

<!-- CSV parser -->
<script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

<script type="module">
  import { initJsPsych } from "https://esm.sh/jspsych";
  import jsPsychHtmlButtonResponse from "https://esm.sh/@jspsych/plugin-html-button-response";
  import jsPsychHtmlSliderResponse from "https://esm.sh/@jspsych/plugin-html-slider-response";

  const jsPsych = initJsPsych({});

  // ---------- helpers ----------
  function getParam(name){
    const m = new URLSearchParams(location.search).get(name);
    return m ? decodeURIComponent(m) : "";
  }
  function hash32(str){
    let h = 2166136261 >>> 0;
    for (let i=0;i<str.length;i++){ h ^= str.charCodeAt(i); h = Math.imul(h, 16777619); }
    return h >>> 0;
  }

  // Build filenames using sync/3s/7s (normalize any "0s" to "sync")
  function filename(scene, version, dir, moa){
    const moaTag = (moa === "0s") ? "sync" : moa;
    return `videos/${scene}_v${version}_${dir}_${moaTag}.mp4`;
  }

  // Parse id like "penguin_v1_q01"
  function parseId(id){
    const m = (id || "").trim().match(/^([a-z0-9_-]+)_v([123])_q(\d+)$/i);
    if(!m) return { scene:"", version:"", q:"" };
    const scene = m[1].toLowerCase();
    const version = `v${m[2]}`;
    const q = m[3];
    return { scene, version, q };
  }

  async function loadCSV(path="logic.csv"){
    return new Promise((resolve, reject)=>{
      Papa.parse(`${path}?cb=${Date.now()}`, {
        download:true,
        header:true,
        skipEmptyLines:true,
        complete: (res)=>{
          const rows = res.data.map(r=>{
            const obj = {};
            for(const k in r) obj[k.trim()] = (r[k] ?? "").toString().trim();
            const {scene, version, q} = parseId(obj.id || "");
            obj.scene = scene;
            obj.version = version;
            obj.q = q;
            return obj;
          });
          resolve(rows);
        },
        error: reject
      });
    });
  }

  function questionsFor(rows, scene, v){
    const sceneKey = (scene||"").toLowerCase();
    const versionKey = (String(v).startsWith("v") ? String(v) : `v${v}`);
    return rows.filter(r => r.scene === sceneKey && r.version === versionKey);
  }

  // Flexible stem getter (accepts stemImage_left | left_stem | stem_left)
  function getStem(q, side){
    const keys = [ `stemImage_${side}`, `${side}_stem`, `stem_${side}` ];
    for (const k of keys){
      const val = q[k];
      if (val && val.trim && val.trim().length) return val.trim();
    }
    return "";
  }

  // Keep playback rate fixed
  function lockRate(video, rate){
    const apply = () => { video.defaultPlaybackRate = rate; video.playbackRate = rate; };
    const end = performance.now() + 2000;
    (function tick(){ apply(); if (performance.now() < end) requestAnimationFrame(tick); })();
    const reapply = () => apply();
    ['play','ratechange','seeking','loadeddata','ended'].forEach(ev => {
      video.addEventListener(ev, reapply);
    });
  }

  function videoTrial(stimulus, meta){
    return {
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <div class="wrap center">
          <p><em>Watch the clip carefully. Click Continue after watching.</em></p>
          <video id="trial-video" width="900" controls playsinline preload="metadata">
            <source src="\${stimulus}" type="video/mp4">
          </video>
        </div>`,
      choices: ["Continue"],
      data: { phase:"video", stimulus, ...meta },
      on_load: () => {
        const btn = document.querySelector(".jspsych-btn");
        const v = document.getElementById("trial-video");

        // Hide the Continue button until video ends
        if (btn) btn.style.display = "none";
        const showContinue = () => { if (btn) btn.style.display = ""; };

        // Remove play/pause controls after first play, and prevent pausing
        const firstPlay = () => {
          v.removeAttribute('controls');
          v.addEventListener('pause', () => { if (!v.ended) v.play().catch(()=>{}); });
          v.removeEventListener('play', firstPlay);
        };
        v.addEventListener('play', firstPlay);

        // Lock playback rate at 1.0
        lockRate(v, 1.0);

        // Reveal Continue when video ends
        v.addEventListener('ended', () => { showContinue(); }, { once:true });

        // Prevent right-click save
        v.addEventListener('contextmenu', e => e.preventDefault());
      }
    };
  }

  function questionTrial(q, side, meta){
    const stem = getStem(q, side);
    const opts = ["a","b","c","d"].map(k => q[`${side}_${k}`]?.trim?.() || "")
                                  .filter(x => x.length>0);
    const correctIndex = Number(q[`correct_${side}_index`]) || 0;
    const label = i => String.fromCharCode(65+i);

    const optionsHTML = opts.map((val,i)=>{
      const isImage = /\.(png|jpe?g|gif|webp)$/i.test(val);
      const content = isImage ? `<img class="optimg" src="${val}" alt="opt ${label(i)}">`
                              : `<div class="opttext">${val}</div>`;
      return `
        <div class="cell">
          <div><strong>${label(i)}</strong></div>
          ${content}
          <div style="margin-top:8px">
            <button class="jspsych-btn" data-choice="${i}">Choose ${label(i)}</button>
          </div>
        </div>`;
    }).join("");

    const stemHTML = stem
      ? (/\.(png|jpe?g|gif|webp)$/i.test(stem) ? `<img class="stem" src="${stem}">`
                                               : `<div class="stem opttext">${stem}</div>`)
      : "";

    const prompt = (q.prompt || "").replace(/^"(.*)"$/,'$1');

    return {
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <div class="wrap">
          <div class="center" style="margin-bottom:8px">
            <p><strong>${prompt}</strong></p>
          </div>
          ${stemHTML}
          <div class="grid">${optionsHTML}</div>
        </div>`,
      choices: [],
      on_load: () => {
        document.querySelectorAll("button[data-choice]").forEach(btn=>{
          btn.onclick = () => {
            const choice = Number(btn.dataset.choice);
            jsPsych.finishTrial({
              phase: "question",
              qid: q.id || "",
              scene: q.scene || "",
              version: q.version || "",
              side,
              choice_index: choice,
              correct_index: correctIndex,
              is_correct: choice === correctIndex,
              ...meta
            });
          };
        });
      }
    };
  }

  // 2a) Preference: 0–4 with text only under 0,2,4
  function prefSlider(t){
    return {
      type: jsPsychHtmlSliderResponse,
      stimulus: '<div class="center"><p><strong>How much did you like the clip you just watched?</strong></p></div>',
      min: 0, max: 4, step: 1, slider_start: 2,
      slider_width: 700,
      labels: ['0 (Not at all)','1','2 (Neutral)','3','4 (Very much)'],
      require_movement: true,
      data: { phase:"preference", ...t }
    };
  }

  // 2b) Simultaneity: 0–4 with text under 0,2,4
  function simultaneitySlider(t){
    return {
      type: jsPsychHtmlSliderResponse,
      stimulus:
        '<div class="center"><p><strong>To what extent did the visual and auditory motion begin at the same time?</strong></p></div>',
      min: 0, max: 4, step: 1, slider_start: 2,
      slider_width: 700,
      labels: ['0 (Very far apart)','1','2 (Somewhat apart)','3','4 (Exactly the same time)'],
      require_movement: true,
      data: { phase:"simultaneity_slider", ...t }
    };
  }

  // ---------- design (sync/3s/7s + your counterbalance) ----------
  const SCENES   = ["dog","horse","penguin","plane","car","roomba"];
  const VERSIONS = [1,2,3];

  // Use "sync" instead of "0s" in the rotation mapping
  const ROTATIONS = [
    { moa:{1:"sync", 2:"3s", 3:"7s"}, dir:{1:"LtoR", 2:"RtoL", 3:"LtoR"} },
    { moa:{1:"3s", 2:"7s", 3:"sync"}, dir:{1:"RtoL", 2:"LtoR", 3:"RtoL"} },
    { moa:{1:"7s", 2:"sync", 3:"3s"}, dir:{1:"LtoR", 2:"RtoL", 3:"LtoR"} }
  ];

  (async () => {
    const pid = getParam("pid") || "";
    const rot = ROTATIONS[ pid ? (hash32(pid) % ROTATIONS.length) : Math.floor(Math.random()*ROTATIONS.length) ];

    // Practice config (override via URL if needed)
    const PRACTICE_VIDEO = getParam("pvid") || "videos/practice_v1.mp4";
    const PRACTICE_SIDE  = (getParam("pside") || "left").toLowerCase() === "right" ? "right" : "left";

    const rows = await loadCSV("logic.csv");

    // ------- practice block: one video + four questions -------
    const practiceQs = questionsFor(rows, "practice", "v1")
      .sort((a,b)=> Number(a.q) - Number(b.q));

    const practiceTimeline = [];
    practiceTimeline.push({
      type: jsPsychHtmlButtonResponse,
      stimulus: `<div class="wrap center">
        <h2>Practice</h2>
        <p>First, you will watch <strong>one practice clip</strong> and answer <strong>4 practice questions</strong> to get familiar with the task.</p>
      </div>`,
      choices: ["Begin Practice"]
    });
    practiceTimeline.push( videoTrial(PRACTICE_VIDEO, { practice:true }) );

    if (practiceQs.length === 0){
      practiceTimeline.push({
        type: jsPsychHtmlButtonResponse,
        stimulus: `<div class="wrap center"><p><em>No practice questions found (scene "practice", version "v1").</em></p></div>`,
        choices: ["Continue"],
        data: { phase:"no_questions_practice" }
      });
    } else {
      practiceQs.forEach(q => {
        practiceTimeline.push( questionTrial(q, PRACTICE_SIDE, { practice:true }) );
      });
    }

    practiceTimeline.push({
      type: jsPsychHtmlButtonResponse,
      stimulus: `<div class="wrap center">
        <p>Great! Practice is complete. The main task will now begin.</p>
      </div>`,
      choices: ["Start Main Task"]
    });

    // ------- main trials -------
    const trials = [];
    for (const scene of SCENES){
      for (const v of VERSIONS){
        const moa = rot.moa[v];
        const dir = rot.dir[v];
        const stim = filename(scene, v, dir, moa);
        trials.push({ scene, version:v, dir, moa, stimulus: stim });
      }
    }
    const shuffled = jsPsych.randomization.shuffle(trials);

    const mainTimeline = [];
    mainTimeline.push({
      type: jsPsychHtmlButtonResponse,
      stimulus: `<div class="wrap center">
        <h2>Welcome</h2>
        <p>You will watch 18 clips (6 scenes × 3 versions). After each clip, please answer all questions.</p>
      </div>`,
      choices: ["Begin"]
    });

    for (const t of shuffled){
      const side = (t.dir === "LtoR") ? "left" : "right";

      // 1) Video (Continue appears only after end, controls removed after first play)
      mainTimeline.push( videoTrial(t.stimulus, t) );

      // 2) Sliders
      mainTimeline.push( prefSlider(t) );
      mainTimeline.push( simultaneitySlider(t) );

      // 3) Memory questions from CSV
      const allQs = questionsFor(rows, t.scene, t.version);
      if (allQs.length === 0){
        mainTimeline.push({
          type: jsPsychHtmlButtonResponse,
          stimulus: `<div class="wrap center"><p><em>No questions found for ${t.scene} v${t.version}.</em></p></div>`,
          choices: ["Continue"],
          data: { phase:"no_questions", ...t }
        });
      } else {
        jsPsych.randomization.shuffle(allQs).forEach(q => {
          mainTimeline.push( questionTrial(q, side, t) );
        });
      }
    }

    mainTimeline.push({
      type: jsPsychHtmlButtonResponse,
      stimulus: '<div class="center"><p>Thanks! You’re all set.</p></div>',
      choices: ['Finish']
    });

    // ------ Google Sheet logging ------
    // Replace with your web app URL
    const SHEET_URL = "https://script.google.com/macros/s/AKfycbzvtPMbYspu9ViCg7v_5PftC27yxh4LU6b7s6BEIUPJ5i-i2ii9-ccrjAL7ViLvmGJUkg/exec";

    jsPsych.on('finish', () => {
      const data = jsPsych.data.get().values();
      data.forEach(row => {
        fetch(SHEET_URL, {
          method: "POST",
          body: JSON.stringify(row),
          headers: { "Content-Type": "application/json" }
        }).catch(err => console.error("Error sending to sheet:", err));
      });
    });

    // ------- run full experiment -------
    jsPsych.run([
      ...practiceTimeline,
      ...mainTimeline
    ]);
  })();
</script>
</html>

