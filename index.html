<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>MOA1</title>
  <link rel="stylesheet" href="https://unpkg.com/jspsych@7.3.4/css/jspsych.css" />
  <style>
    .jspsych-content-wrapper { display:flex; justify-content:center; }
    .jspsych-content { max-width: 960px !important; margin: 40px auto !important; }
    body { font-family: system-ui, sans-serif; background:#fafafa; }
    .center { text-align:center; }
    video { display:block; margin: 0 auto; border-radius: 10px; background:#000; }

    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:16px; align-items:start; }
    .cell { text-align:center; }
    .tag { font-weight:700; margin:6px 0 8px; }

    /* Slider labels: 0–4 arranged under ticks */
    .jspsych-slider-container .jspsych-slider-labels {
      display: flex !important;
      justify-content: space-between !important;
      gap: 0 !important;
      margin-top: 10px !important;
      font-size: 14px !important;
      line-height: 1.2 !important;
      color: #111 !important;
      white-space: nowrap !important;
    }
    .jspsych-slider-container .jspsych-slider-label {
      text-align: center !important;
      flex: 0 0 auto !important;
    }

    /* Hide (most) timeline/time UI while keeping play to start */
    video::-webkit-media-controls-timeline,
    video::-webkit-media-controls-current-time-display,
    video::-webkit-media-controls-time-remaining-display {
      display: none !important;
    }
    video::-moz-media-controls-seekbar {
      display: none !important;
    }
  </style>
</head>
<body></body>

<script type="module">
  // surface errors to the page if something breaks
  window.onerror = (m, s, l, c, e) => {
    document.body.innerHTML = "<pre>"+m+"\n"+(e && e.stack || "")+"</pre>";
  };

  import { initJsPsych } from "https://esm.sh/jspsych";
  import jsPsychHtmlSliderResponse from "https://esm.sh/@jspsych/plugin-html-slider-response";
  import jsPsychHtmlButtonResponse from "https://esm.sh/@jspsych/plugin-html-button-response";

  // --- helpers ---
  function getParam(name){
    const m = new URLSearchParams(location.search).get(name);
    return m ? decodeURIComponent(m) : "";
  }

  // optional: Google Sheets upload (you can keep or remove)
  const GS_WEBAPP_URL = ""; // put your Apps Script URL here if you want

  const jsPsych = initJsPsych({
    on_finish: async () => {
      if (!GS_WEBAPP_URL) { jsPsych.data.displayData(); return; }
      const payload = {
        timestamp: new Date().toISOString(),
        participant: getParam('pid') || '',
        data: jsPsych.data.get().values()
      };
      try {
        await fetch(GS_WEBAPP_URL, {
          method: 'POST', mode: 'no-cors',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload), keepalive: true
        });
        alert('Thanks! Your data was uploaded.');
      } catch (e) {
        console.error(e);
        jsPsych.data.get().localSave('csv','moa1.csv');
        alert('Upload failed — CSV downloaded locally instead.');
      }
    }
  });

  // lock playback rate utility (for wrong-speed foils)
  function lockRate(video, rate){
    const apply = () => { video.defaultPlaybackRate = rate; video.playbackRate = rate; };
    const end = performance.now() + 2000;
    (function tick(){ apply(); if (performance.now() < end) requestAnimationFrame(tick); })();
    const reapply = () => apply();
    ['play','ratechange','seeking','loadeddata','ended'].forEach(ev => {
      video.addEventListener(ev, reapply);
    });
  }

  // 1) Video trial: hide progress/time; user must watch full; no seeking/pausing
  function viewClip(t){
    const html = `
      <div class="center">
        <p id="watchmsg"><em>Click Play to watch the full clip. The Continue button will appear when it ends.</em></p>
        <video id="mainvid" width="900" controls playsinline preload="metadata"
               controlslist="nodownload noplaybackrate noremoteplayback nofullscreen"
               disablePictureInPicture>
          <source src="${t.stimulus}" type="video/mp4">
        </video>
        <div id="btnbox" style="margin-top:10px"></div>
      </div>
    `;
    return {
      type: jsPsychHtmlButtonResponse,
      stimulus: html,
      choices: [],   // no built-in button; we reveal our own after 'ended'
      data: { phase:"view", ...t },
      on_load: () => {
        const v   = document.getElementById('mainvid');
        const box = document.getElementById('btnbox');
        const msg = document.getElementById('watchmsg');
        let revealed = false;

        // prevent right-click and some key controls
        v.addEventListener('contextmenu', e => e.preventDefault());
        document.addEventListener('keydown', e => {
          // block Space (pause), ArrowLeft/Right (seek) while video controls are removed
          if ([' ', 'ArrowLeft', 'ArrowRight', 'MediaTrackNext', 'MediaTrackPrevious'].includes(e.key)) {
            e.preventDefault();
          }
        }, { capture:true });

        // once they press Play, remove controls & enforce no pause/seek
        const firstPlay = () => {
          v.removeAttribute('controls'); // remove controls to kill timeline & buttons
          // disallow pausing mid-play
          v.addEventListener('pause', () => {
            if (!v.ended) v.play().catch(()=>{});
          });
          // disallow seeking
          let last = 0;
          v.addEventListener('timeupdate', () => { if (v.currentTime > last) last = v.currentTime; });
          v.addEventListener('seeking', () => {
            if (v.currentTime > last + 0.05) { // attempted forward seek
              try { v.currentTime = last; } catch (e) {}
            }
          });
          v.removeEventListener('play', firstPlay);
        };
        v.addEventListener('play', firstPlay);

        // reveal Continue only after it ends
        const showContinue = () => {
          if (revealed) return;
          revealed = true;
          msg.textContent = 'You can continue.';
          const btn = document.createElement('button');
          btn.className = 'jspsych-btn';
          btn.textContent = 'Continue →';
          btn.onclick = () => jsPsych.finishTrial({ phase:"view", ...t });
          box.appendChild(btn);
        };
        v.addEventListener('ended', showContinue, { once:true });
      }
    };
  }

  // 2a) Preference slider (0–4)
  function prefSlider(t){
    return {
      type: jsPsychHtmlSliderResponse,
      stimulus: '<div class="center"><p><strong>How much did you like the clip you just watched?</strong></p></div>',
      min: 0, max: 4, step: 1, slider_start: 2, slider_width: 700,
      labels: ['0 (Not at all)','1','2 (Neutral)','3','4 (Very much)'],
      require_movement: true,
      data: { phase:"preference", ...t }
    };
  }

  // 2b) Simultaneity slider (0–4)
  function simultaneitySlider(t){
    return {
      type: jsPsychHtmlSliderResponse,
      stimulus:
        '<div class="center">' +
          '<p><strong>To what extent did the visual and auditory motion begin at the same time?</strong></p></div>',
      min: 0, max: 4, step: 1, slider_start: 2, slider_width: 700,
      labels: ['0 (Very far apart)','1','2 (Somewhat apart)','3','4 (Exactly the same time)'],
      require_movement: true,
      data: { phase:"simultaneity_slider", ...t }
    };
  }

  // 3) 4AFC memory: correct, wrong-dir, wrong-speed (0.7x), both-wrong
  function memoryTrial(t){
    const flip = t.direction === "LtoR" ? "RtoL" : "LtoR";
    const correct   = { src:`videos/${t.scene}_${t.direction}_${t.moa}.mp4`, rate:1.0, tag:'correct' };
    const wrongDir  = { src:`videos/${t.scene}_${flip}_${t.moa}.mp4`,        rate:1.0, tag:'wrong_dir' };
    const wrongSpd  = { src: correct.src,                                    rate:0.7, tag:'wrong_speed' };
    const bothWrong = { src: wrongDir.src,                                   rate:0.7, tag:'both_wrong' };

    const opts = jsPsych.randomization.shuffle([correct, wrongDir, wrongSpd, bothWrong]);
    const correct_index = opts.findIndex(o => o.tag === 'correct');
    const letters = ['A','B','C','D'];

    const gridHTML = `
      <div class="grid">
        ${opts.map((o,i)=>`
          <div class="cell">
            <div class="tag">${letters[i]}</div>
            <video id="opt${i}" muted loop playsinline preload="auto" width="420"
                   controlslist="nodownload noplaybackrate noremoteplayback nofullscreen"
                   disablePictureInPicture>
              <source src="${o.src}" type="video/mp4">
            </video>
          </div>
        `).join('')}
      </div>
      <div class="center"><p><em>Which clip matches the one you just watched (same direction & speed)?</em></p></div>
    `;

    return {
      type: jsPsychHtmlButtonResponse,
      stimulus: gridHTML,
      choices: letters,
      on_load: () => {
        // ensure each option plays; lock speed for wrong-speed foils
        opts.forEach((o,i)=>{
          const v = document.getElementById(`opt${i}`);
          v.muted = true; v.playsInline = true; v.load();
          const start = () => {
            if (o.rate !== 1.0) lockRate(v, o.rate); else { v.playbackRate = 1.0; }
            try { if (v.currentTime === 0) v.currentTime = 0.001; } catch(e){}
            v.play().catch(()=>{ /* user click will start if blocked */ });
          };
          v.addEventListener('loadeddata', start, { once:true });
          v.addEventListener('canplay',     start, { once:true });
        });
      },
      data: {
        phase:"memory",
        ...t,
        memory_option_order: opts.map(o=>o.tag).join(','),
        correct_index
      },
      on_finish: d => {
        d.choice_index = d.response;
        d.is_correct   = (d.response === correct_index);
      }
    };
  }

  // ---------- PRACTICE (2 trials, each: video → pref → sim → memory practice) ----------
  function memoryTrialPractice(t){
    const p1 = "videos/practice1_LtoR_demo.mp4";
    const p2 = "videos/practice2_RtoL_demo.mp4";
    const partner = (t.scene === "practice1") ? p2 : p1;

    const correct   = { src: t.stimulus, rate: 1.0, tag:'correct' };
    const wrongDir  = { src: partner,    rate: 1.0, tag:'wrong_dir' };
    const wrongSpd  = { src: t.stimulus, rate: 0.7, tag:'wrong_speed' };
    const bothWrong = { src: partner,    rate: 0.7, tag:'both_wrong' };

    const opts = jsPsych.randomization.shuffle([correct, wrongDir, wrongSpd, bothWrong]);
    const correct_index = opts.findIndex(o => o.tag === 'correct');
    const letters = ['A','B','C','D'];

    const gridHTML = `
      <div class="grid">
        ${opts.map((o,i)=>`
          <div class="cell">
            <div class="tag">${letters[i]}</div>
            <video id="opt${i}" muted loop playsinline preload="auto" width="420"
                   controlslist="nodownload noplaybackrate noremoteplayback nofullscreen"
                   disablePictureInPicture>
              <source src="${o.src}" type="video/mp4">
            </video>
          </div>
        `).join('')}
      </div>
      <div class="center"><p><em>Which clip matches the one you just watched (same direction & speed)?</em></p></div>
    `;

    return {
      type: jsPsychHtmlButtonResponse,
      stimulus: gridHTML,
      choices: letters,
      on_load: () => {
        opts.forEach((o,i)=>{
          const v = document.getElementById(`opt${i}`);
          v.muted = true; v.playsInline = true; v.load();
          const start = () => {
            if (o.rate !== 1.0) lockRate(v, o.rate); else { v.playbackRate = 1.0; }
            try { if (v.currentTime === 0) v.currentTime = 0.001; } catch(e){}
            v.play().catch(()=>{});
          };
          v.addEventListener('loadeddata', start, { once:true });
          v.addEventListener('canplay',     start, { once:true });
        });
      },
      data: { phase:"memory_practice", ...t, memory_option_order: opts.map(o=>o.tag).join(','), correct_index },
      on_finish: d => { d.choice_index = d.response; d.is_correct = (d.response === correct_index); }
    };
  }

  const practiceTrials = [
    { scene:"practice1", direction:"LtoR", moa:"demo", stimulus:"videos/practice1.mp4" },
    { scene:"practice2", direction:"RtoL", moa:"demo", stimulus:"videos/practice2.mp4" }
  ];

  const practiceTimeline = [
    { type: jsPsychHtmlButtonResponse,
      stimulus: '<div class="center"><h2>Practice</h2><p>Welcome! You will start with 2 practice trials to learn the task.</p></div>',
      choices: ['Begin practice'] }
  ];

  practiceTrials.forEach(T => {
    practiceTimeline.push(viewClip(T));
    practiceTimeline.push(prefSlider(T));
    practiceTimeline.push(simultaneitySlider(T));
    practiceTimeline.push(memoryTrialPractice(T));
  });

  practiceTimeline.push({
    type: jsPsychHtmlButtonResponse,
    stimulus: '<div class="center"><p>Practice complete. The main experiment will now begin.</p></div>',
    choices: ['Continue']
  });

  // ---------- MAIN (36 trials): all combinations of 6 scenes × 2 directions × 3 MOAs ----------
  const scenes     = ["car","dog","horse","penguin","plane","roomba"];
  const directions = ["LtoR","RtoL"];
  const moas       = ["0s","3s","7s"]; // if your files use "sync", change "0s" to "sync" here

  const allTrials = [];
  scenes.forEach(scene=>{
    directions.forEach(dir=>{
      moas.forEach(moa=>{
        allTrials.push({
          scene, direction: dir, moa,
          stimulus: `videos/${scene}_${dir}_${moa}.mp4`
        });
      });
    });
  });

  // Shuffle but avoid two identical scene+direction in a row
  function shuffleWithConstraint(trials){
    let shuffled = jsPsych.randomization.shuffle(trials);
    let attempts = 0;
    while(attempts < 1000){
      let ok = true;
      for(let i=1;i<shuffled.length;i++){
        if(shuffled[i-1].scene === shuffled[i].scene &&
           shuffled[i-1].direction === shuffled[i].direction){
          ok = false; break;
        }
      }
      if(ok) return shuffled;
      shuffled = jsPsych.randomization.shuffle(trials);
      attempts++;
    }
    return shuffled;
  }
  const constrained = shuffleWithConstraint(allTrials);

  const mainTimeline = [];
  constrained.forEach(T => {
    mainTimeline.push(viewClip(T));
    mainTimeline.push(prefSlider(T));
    mainTimeline.push(simultaneitySlider(T));
    mainTimeline.push(memoryTrial(T));
  });

  mainTimeline.push({
    type: jsPsychHtmlButtonResponse,
    stimulus: '<div class="center"><p>Thanks! All trials complete.</p></div>',
    choices: ['Finish']
  });

  // Run everything
  jsPsych.run([
    ...practiceTimeline,
    ...mainTimeline
  ]);
</script>
</html>


